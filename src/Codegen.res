type t = {
  config: Types.ancestorConfig,
  parts: array<string>,
}

type part =
  | Breakpoints
  | ZIndex
  | Spacing
  | Radius

let make = config => {
  {config, parts: []}
}

let capitalize = s => {
  s->Js.String2.charAt(0)->Js.String2.toLocaleUpperCase ++ s->Js.String2.sliceToEnd(~from=1)
}

let generateBreakpointsType = keys => {
  let breakpointsTypeOpen = `
  type breakpoints<'a> = {
`

  let breakpointsTypeClose = `
  }`

  let breakpointsTypeBody = keys->Js.Array2.map(key => `    ${key}?: 'a,`)->Js.Array2.joinWith("\n")

  breakpointsTypeOpen ++ breakpointsTypeBody ++ breakpointsTypeClose
}

let generateFieldType = keys => {
  let fieldTypeOpen = `
  type fields = `

  let fieldTypeBody = keys->Js.Array2.map(capitalize)->Js.Array2.joinWith(" | ")

  fieldTypeOpen ++ fieldTypeBody
}

let generateEncodeFunction = keys => {
  let encodeFunctionOpen = `
  let encode = breakpoints = [
`

  let encodeFunctionClose = `
  ]`

  let encodeFunctionBody =
    keys
    ->Js.Array2.map(key => `    (${capitalize(key)}, breakpoints.${key}),`)
    ->Js.Array2.joinWith("\n")

  encodeFunctionOpen ++ encodeFunctionBody ++ encodeFunctionClose
}

let generateSizeByBreakpointsFunction = entries => {
  let sizeByBreakpointsFunctionOpen = `
  let sizeByBreakpoints = breakpoint =>
    switch breakpoint {
`

  let sizeByBreakpointsFunctionClose = `
    }
`

  let sizeByBreakpointsFunctionBody =
    entries
    ->Js.Array2.map(entry => {
      let (key, value) = entry
      `      | ${capitalize(key)} => ${Js.Int.toString(value)}`
    })
    ->Js.Array2.joinWith("\n")

  sizeByBreakpointsFunctionOpen ++ sizeByBreakpointsFunctionBody ++ sizeByBreakpointsFunctionClose
}

let generateBreakpoints = breakpoints => {
  generateBreakpointsType(breakpoints->Js.Dict.keys) ++
  "\n" ++
  generateFieldType(breakpoints->Js.Dict.keys) ++
  "\n" ++
  generateEncodeFunction(breakpoints->Js.Dict.keys) ++
  "\n" ++
  generateSizeByBreakpointsFunction(breakpoints->Js.Dict.entries)
}

let generateZIndexType = keys => {
  let zIndexTypeOpen = `
  type zIndex = `

  let zIndexTypeBody = keys->Js.Array2.map(key => `#${key}`)->Js.Array2.joinWith(" | ")

  zIndexTypeOpen ++ "[ " ++ zIndexTypeBody ++ " ]"
}

let generateZIndexFunction = entries => {
  let zIndexFunctionOpen = `
  let zIndex = v =>
    switch v {
`

  let zIndexFunctionClose = `
    }
`

  let zIndexFunctionBody =
    entries
    ->Js.Array2.map(entry => {
      let (key, value) = entry
      `      | #${key} => ${Js.Int.toString(value)}`
    })
    ->Js.Array2.joinWith("\n")

  zIndexFunctionOpen ++ zIndexFunctionBody ++ zIndexFunctionClose
}

let generateZIndex = zIndex => {
  generateZIndexType(zIndex->Js.Dict.keys) ++
  "\n" ++
  generateZIndexFunction(zIndex->Js.Dict.entries)
}

let generateSpacingType = () => {
  let spacingTypeOpen = `
  type spacing = `

  let spacingTypeBody = "int"

  spacingTypeOpen ++ spacingTypeBody
}

let generateSpacingFunction = body => {
  let spacingFunctionOpen = `  let spacing = `

  let spacingFunctionBody =
    body->Js.String2.substr(~from=body->Js.String2.indexOf("=>") + 2)->Js.String2.trim

  spacingFunctionOpen ++ "#px(" ++ spacingFunctionBody ++ ")"
}

let generateSpacing = fn => {
  generateSpacingType() ++ "\n" ++ generateSpacingFunction(Function.stringifyAny1(fn)) ++ "\n"
}

let generateRadiusType = () => {
  let spacingTypeOpen = `
  type radius = `

  let spacingTypeBody = "int"

  spacingTypeOpen ++ spacingTypeBody
}

let generateRadiusFunction = body => {
  let spacingFunctionOpen = `  let radius = `

  let spacingFunctionBody =
    body->Js.String2.substr(~from=body->Js.String2.indexOf("=>") + 2)->Js.String2.trim

  spacingFunctionOpen ++ "#px(" ++ spacingFunctionBody ++ ")"
}

let generateRadius = fn => {
  generateRadiusType() ++ "\n" ++ generateRadiusFunction(Function.stringifyAny1(fn)) ++ "\n"
}

let generate = (t, part) => {
  switch part {
  | Breakpoints => {
      ...t,
      parts: t.parts->Js.Array2.concat([generateBreakpoints(t.config.breakpoints)]),
    }
  | ZIndex => {
      ...t,
      parts: t.parts->Js.Array2.concat([generateZIndex(t.config.zIndex)]),
    }
  | Spacing => {
      ...t,
      parts: t.parts->Js.Array2.concat([generateSpacing(t.config.spacing)]),
    }
  | Radius => {
      ...t,
      parts: t.parts->Js.Array2.concat([generateRadius(t.config.radius)]),
    }
  }
}

let functorOpen = `
module AncestorX = Ancestor.Make({`

let functorClose = `
})`

let colors = `
  type colors = Ancestor_Css.Color.t
  let colors = v => v`

let print = t => {
  "// Generated by Ancestor. Edit with care :)" ++
  "\n" ++
  functorOpen ++
  t.parts->Js.Array2.reduce((acc, part) => acc ++ part, "") ++
  colors ++
  functorClose
}
